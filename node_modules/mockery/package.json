{
  "author": {
    "name": "Martin Cooper",
    "email": "mfncooper@gmail.com"
  },
  "contributors": [
    {
      "name": "Bryan Donovan",
      "email": "bdondo@gmail.com"
    }
  ],
  "name": "mockery",
  "description": "Simplifying the use of mocks with Node.js",
  "version": "1.1.2",
  "repository": {
    "type": "git",
    "url": "git://github.com/mfncooper/mockery.git"
  },
  "bugs": {
    "url": "http://github.com/mfncooper/mockery/issues"
  },
  "main": "mockery.js",
  "engines": {
    "node": ">=0.4.5"
  },
  "dependencies": {},
  "devDependencies": {
    "nodeunit": "0.6.x",
    "sinon": "1.2.x"
  },
  "scripts": {
    "test": "test/run.js"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/mfncooper/mockery/raw/master/LICENSE"
    }
  ],
  "readme": "# Mockery - Simplifying the use of mocks with Node.js\n\n[![Build Status](https://secure.travis-ci.org/mfncooper/mockery.png)](http://travis-ci.org/mfncooper/mockery)\n\nIf you've tried working with mocks in Node.js, you've no doubt discovered that\nit's not so easy to get your mocks hooked up in the face of Node's module\nloading system. When your source-under-test pulls in its dependencies through\n`require`, you want your mocks provided, instead of the original module,\nto enable true unit testing of your code.\n\nThis is exactly the problem Mockery is designed to solve. Mockery gives you a\nsimple and easy to use API with which you can hook in your mocks without having\nto get your hands dirty with the `require` cache or other Node implementation\ndetails.\n\nMockery is *not* a mocking framework. It lets you work more easily with your\nframework of choice (or no framework) to get your mocks hooked in to all the\nright places in the code you need to test.\n\n## Installation\n\nJust use npm:\n\n    npm install mockery\n\n## Enabling mockery\n\nWhen enabled, Mockery intercepts *all* `require` calls, regardless of where\nthose calls are being made from. Thus it's almost always desirable to bracket\nyour usage as narrowly as possible.\n\nIf you're using a typical unit testing framework, you might enable and disable\nMockery in the test setup and teardown functions for your test cases. Something\nlike this:\n\n    setUp: function() {\n        mockery.enable();\n    },\n    tearDown: function() {\n        mockery.disable();\n    }\n\n## Registering mocks\n\nYou register your mocks with Mockery to tell it which mocks to provide for which\n`require` calls. For example:\n\n    var fsMock = {\n        stat: function (path, cb) { /* your mock code */ }\n    };\n    mockery.registerMock('fs', fsMock);\n\nThe arguments to `registerMock` are as follows:\n\n* _module_, the name or path of the module for which a mock is being\nregistered. This must exactly match the argument to `require`; there is no\n\"clever\" matching.\n* _mock_, the mock to be provided. Whatever is provided here is what will\nbecome the result of subsequent `require` calls; that is, the `exports` of the\nmodule.\n\nIf you no longer want your mock to be used, you can deregister it:\n\n    mockery.deregisterMock('fs');\n\nNow the original module will be provided for any subsequent `require` calls.\n\n## Registering substitutes\n\nSometimes you want to implement your mock itself as a module, especially if it's\nmore complicated and you'll be reusing it more widely. In that case, you can\ntell Mockery to substitute that module for the original one. For example:\n\n    mockery.registerSubstitute('fs', 'fs-mock');\n\nNow any `require` invocation for 'fs' will be satisfied by loading the 'fs-mock'\nmodule instead.\n\nThe arguments to `registerSubstitute` are as follows:\n\n* _module_, the name or path of the module for which a substitute is being\nregistered. This must exactly match the argument to `require`; there is no\n\"clever\" matching.\n* _substitute_, the name or path of the module to substitute for _module_.\n\nIf you no longer want your substitute to be used, you can deregister it:\n\n    mockery.deregisterSubstitute('fs');\n\nNow the original module will be provided for any subsequent `require` calls.\n\n## Registering allowable modules\n\nIf you enable Mockery and _don't_ mock or substitute a module that is later\nloaded via `require`, Mockery will print a warning to the console to tell you\nthat. This is so that you don't inadvertently use downstream modules without\nbeing aware of them. By registering a module as \"allowable\", you tell Mockery\nthat you know about its use, and then Mockery won't print the warning.\n\nThe most common use case for this is your source-under-test, which obviously\nyou'll want to load without warnings. For example:\n\n    mockery.registerAllowable('./my-source-under-test');\n\nAs with `registerMock` and `registerSubstitute`, the first argument, _module_,\nis the name or path of the module as it would be provided to `require`. Once\nagain, you can deregister it if you need to:\n\n    mockery.deregisterAllowable('./my-source-under-test');\n\n### Unhooking\n\nBy default, the Node module loader will load a given module only once, caching\nthe loaded module for the lifetime of the process. When you're using Mockery,\nthis is almost always what you want. _Almost_. In relatively rare situations,\nyou may find that you need to use different mocks for different test cases\nfor the same source-under-test. (This is not the same as supplying different\ntest data in the same mock; here we're talking about providing different\nfunctions for a module's `exports`.)\n\nTo do this, your source-under-test must be unhooked from Node's module loading\nsystem, such that it can be loaded again with new mocks. You do this by passing\na second argument, _unhook_, to `registerAllowable`, like this:\n\n    mockery.registerAllowable('./my-source-under-test', true);\n\nWhen you subsequently deregister your source-under-test, Mockery will unhook it\nfrom the Node module loading system as well as deregistering it.\n\n## Deregistering everything\n\nSince it's such a common use case, especially when you're using a unit test\nframework and its setup and teardown functions, Mockery provides a convenience\nfunction to deregister everything:\n\n    mockery.deregisterAll();\n\nThis will deregister all mocks, substitutes, and allowable modules, as well as\nunhooking any hooked modules.\n\n## Disabling warnings\n\nAs mentioned above, if you enable Mockery and _don't_ mock, substitute, or\nallow a module that is later loaded, Mockery will print a warning to the\nconsole to tell you that. This is important when you're writing unit tests,\nso that you don't end up using modules you weren't aware of.\n\nIn certain circumstances, such as when writing functional or integration tests,\nyou may find it irritating to have to allow each module or to have all the\nwarnings appear on the console. If you need to, you can tell Mockery to turn\noff those warnings:\n\n    mockery.warnOnUnregistered(false);\n\nIf you later need to re-enable the warnings, then passing `true` to the same\nfunction will do that, as you might imagine.\n\n## The name\n\nMockery is to mocks as rookery is to rooks.\n\n## License\n\nMockery is licensed under the [MIT License](http://github.com/mfncooper/mockery/raw/master/LICENSE).\n",
  "_id": "mockery@1.1.2",
  "_from": "mockery@latest"
}
